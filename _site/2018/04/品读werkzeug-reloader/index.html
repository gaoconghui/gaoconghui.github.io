<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>品读 werkzeug reloader 实现机制</title>
  <meta name="description" content="werkzeug使用reloader可以在文件被改变时自动加载更改过的文件，使用方法也很简单，run_simple('localhost', 4000, application,use_reloader=True)，ues_reloader=True即可。本文试图去品读一下reloader的实现以及一些小细节。">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="品读 werkzeug reloader 实现机制">
  <meta name="twitter:description" content="werkzeug使用reloader可以在文件被改变时自动加载更改过的文件，使用方法也很简单，run_simple('localhost', 4000, application,use_reloader=True)，ues_reloader=True即可。本文试图去品读一下reloader的实现以及一些小细节。">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="品读 werkzeug reloader 实现机制">
  <meta property="og:description" content="werkzeug使用reloader可以在文件被改变时自动加载更改过的文件，使用方法也很简单，run_simple('localhost', 4000, application,use_reloader=True)，ues_reloader=True即可。本文试图去品读一下reloader的实现以及一些小细节。">
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://gaoconghui.github.io/2018/04/%E5%93%81%E8%AF%BBwerkzeug-reloader/">
  <link rel="alternate" type="application/rss+xml" title="Gao Conghui" href="http://gaoconghui.github.io/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 Gao Conghui 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="Gao Conghui logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for Gao Conghui" class="blog-button">Gao Conghui</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">好好学习，天天向上</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">一点资讯，视频爬虫，视频处理。</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="Visit blog" class="blog-button">Blog</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/https://github.com/gaoconghui" title="@https://github.com/gaoconghui 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:381147882@qq.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-blue"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-04-24 21:00:00 +0800" itemprop="datePublished" class="post-meta__date date">2018-04-24</time> &#8226; <span class="post-meta__tags tags">python werkzeug</span>
    </div>
    <h1 class="post-title">品读 werkzeug reloader 实现机制</h1>
  </header>

  <section class="post">
    <p>werkzeug使用reloader可以在文件被改变时自动加载更改过的文件，使用方法也很简单，<code class="highlighter-rouge">run_simple('localhost', 4000, application,use_reloader=True)</code>，ues_reloader=True即可。本文试图去品读一下reloader的实现以及一些小细节。</p>

<h3 id="原理">原理</h3>

<p>先概述下整个reloader的原理，看起来会舒服一些。</p>

<p>非reloader的启动很简单，会调用<code class="highlighter-rouge">make_server</code>方法，然后调用<code class="highlighter-rouge">serve_forever()</code>去循环获取新的请求。</p>

<p>而reloader的机制，会起一个子进程，子进程有两个线程，一个线程会去跑server，一个线程去监控文件是否变动，如果文件发生变动，子进程会退出，并返回返回码3（自定义的返回码，标识因为文件变化而退出）。父进程检测子进程的退出码，并加以判断，如果是3，则重复上面的步骤，去再启动一次子进程，当然，此时加载的文件都会是新的文件了。</p>

<h3 id="代码角度">代码角度</h3>

<p>接下来从代码的角度出发，看下整个流程。</p>

<h4 id="入口">入口</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">'WERKZEUG_SERVER_FD'</span><span class="p">])</span>
    <span class="k">except</span> <span class="p">(</span><span class="nb">LookupError</span><span class="p">,</span> <span class="nb">ValueError</span><span class="p">):</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">srv</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">application</span><span class="p">,</span> <span class="n">threaded</span><span class="p">,</span>
                      <span class="n">processes</span><span class="p">,</span> <span class="n">request_handler</span><span class="p">,</span>
                      <span class="n">passthrough_errors</span><span class="p">,</span> <span class="n">ssl_context</span><span class="p">,</span>
                      <span class="n">fd</span><span class="o">=</span><span class="n">fd</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fd</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">log_startup</span><span class="p">(</span><span class="n">srv</span><span class="o">.</span><span class="n">socket</span><span class="p">)</span>
    <span class="n">srv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>

<span class="k">if</span> <span class="n">use_reloader</span><span class="p">:</span>
    <span class="c"># If we're not running already in the subprocess that is the</span>
    <span class="c"># reloader we want to open up a socket early to make sure the</span>
    <span class="c"># port is actually available.</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'WERKZEUG_RUN_MAIN'</span><span class="p">)</span> <span class="o">!=</span> <span class="s">'true'</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">port</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">can_open_by_fd</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="s">'Cannot bind to a random port with enabled '</span>
                             <span class="s">'reloader if the Python interpreter does '</span>
                             <span class="s">'not support socket opening by fd.'</span><span class="p">)</span>

        <span class="c"># Create and destroy a socket so that any exceptions are</span>
        <span class="c"># raised before we spawn a separate Python interpreter and</span>
        <span class="c"># lose this ability.</span>
        <span class="n">address_family</span> <span class="o">=</span> <span class="n">select_ip_version</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">address_family</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">get_sockaddr</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">address_family</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">'set_inheritable'</span><span class="p">):</span>
            <span class="n">s</span><span class="o">.</span><span class="n">set_inheritable</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># If we can open the socket by file descriptor, then we can just</span>
        <span class="c"># reuse this one and our socket will survive the restarts.</span>
        <span class="k">if</span> <span class="n">can_open_by_fd</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">'WERKZEUG_SERVER_FD'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
            <span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="n">LISTEN_QUEUE</span><span class="p">)</span>
            <span class="n">log_startup</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c"># Do not use relative imports, otherwise "python -m werkzeug.serving"</span>
    <span class="c"># breaks.</span>
    <span class="kn">from</span> <span class="nn">werkzeug._reloader</span> <span class="kn">import</span> <span class="n">run_with_reloader</span>
    <span class="n">run_with_reloader</span><span class="p">(</span><span class="n">inner</span><span class="p">,</span> <span class="n">extra_files</span><span class="p">,</span> <span class="n">reloader_interval</span><span class="p">,</span>
                      <span class="n">reloader_type</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">inner</span><span class="p">()</span>
</code></pre></div></div>

<p>上面就是<code class="highlighter-rouge">use_reloader</code>起作用部分的代码。可以看到，使用了<code class="highlighter-rouge">use_reloader</code>之后相比较没加做了很多事情（废话 = = ）。接下去会挑这几行代码里的需要注意的点讲下。</p>

<ul>
  <li>
    <p>WERKZEUG_RUN_MAIN</p>

    <p><code class="highlighter-rouge">WERKZEUG_RUN_MAIN</code>在这里其实还没赋值，看不太出具体的作用，可以在后面再看。初始肯定是null，<strong>第一次</strong>执行这几行代码的时候是会进入到if语句的（实际上这几行代码在每次代码更新执行reloader的时候都会重复进入，后面再说）</p>
  </li>
  <li>
    <p>can_open_by_fd</p>

    <p>这个参数是前面定义的，<code class="highlighter-rouge">can_open_by_fd = not WIN and hasattr(socket, 'fromfd')</code>，先不管windows系统下的情况，后面的fromdfd方法的解释如下</p>

    <blockquote>
      <p>create a socket object from an open file descriptor [*]</p>
    </blockquote>

    <p>即从文件描述符创建一个socket。后面会创建一个socket，并把socket的文件描述符保存起来，方面传递。（实际上会在父进程子进程之间进行传递）</p>
  </li>
  <li>
    <p>socket.SO_REUSEADDR</p>

    <p>允许使用<code class="highlighter-rouge">TIME_WAIT</code>的端口。我们知道，TIME_WAIT状态下的端口是无法使用的，加上socket.SO_REUSEADDR参数后使这个socket的端口之后可以重复使用。</p>
  </li>
  <li>
    <p>为什么直接创建一个socket，而不是在<code class="highlighter-rouge">inner</code>中使用<code class="highlighter-rouge">make_server</code>去创建？</p>

    <p>因为需要传递fd，在整个程序的入口需要先行创建。在后边我们会看到，子进程回去使用fd去创建socket（或者说是从fd恢复socket）</p>
  </li>
  <li>
    <p>inner</p>

    <p>在<code class="highlighter-rouge">use_reloader</code>为true的情况下，fd是存在的，会运行一个server，并且使用该fd对应的socket</p>
  </li>
</ul>

<p>在处理完是否为<code class="highlighter-rouge">WERKZEUG_RUN_MAIN</code>的情况后，程序进入<code class="highlighter-rouge">run_with_reloader</code>方法。</p>

<h4 id="run_with_reloader">run_with_reloader</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run_with_reloader</span><span class="p">(</span><span class="n">main_func</span><span class="p">,</span> <span class="n">extra_files</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                      <span class="n">reloader_type</span><span class="o">=</span><span class="s">'auto'</span><span class="p">):</span>
    <span class="s">"""Run the given function in an independent python interpreter."""</span>
    <span class="kn">import</span> <span class="nn">signal</span>
    <span class="n">reloader</span> <span class="o">=</span> <span class="n">reloader_loops</span><span class="p">[</span><span class="n">reloader_type</span><span class="p">](</span><span class="n">extra_files</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>
    <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">sys</span><span class="o">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'WERKZEUG_RUN_MAIN'</span><span class="p">)</span> <span class="o">==</span> <span class="s">'true'</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">main_func</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">())</span>
            <span class="n">t</span><span class="o">.</span><span class="n">setDaemon</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="n">reloader</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="nb">exit</span><span class="p">(</span><span class="n">reloader</span><span class="o">.</span><span class="n">restart_with_reloader</span><span class="p">())</span>
    <span class="k">except</span> <span class="nb">KeyboardInterrupt</span><span class="p">:</span>
        <span class="k">pass</span>
</code></pre></div></div>

<p>先往下看下<code class="highlighter-rouge">if</code>语句。同样的，第一次进入，还没赋值<code class="highlighter-rouge">WERKZEUG_RUN_MAIN</code>，会进去<code class="highlighter-rouge">sys.exit(reloader.restart_with_reloader())</code>，会把<code class="highlighter-rouge">reloader.restart_with_reloader()</code>的返回值作为程序的退出码。</p>

<p><code class="highlighter-rouge">reloader_loops</code>是一个监控文件变化的类，有两个实现，分别是<code class="highlighter-rouge">StatReloaderLoop</code>以及<code class="highlighter-rouge">WatchDogReloaderLoop</code>，二者区别在于监控文件变动的方法不同。</p>

<h4 id="reloaderloop">ReloaderLoop</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ReloaderLoop</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_sleep</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extra_files</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
      	<span class="c"># 接受 extra_files 参数，除了监控.py的变化以外，还会监控 extra_files 列表中所有文件的变化</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_files</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">extra_files</span> <span class="ow">or</span> <span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interval</span> <span class="o">=</span> <span class="n">interval</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">restart_with_reloader</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_log</span><span class="p">(</span><span class="s">'info'</span><span class="p">,</span> <span class="s">' * Restarting with </span><span class="si">%</span><span class="s">s'</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="c"># 获取到启动脚本，如['/usr/bin/python','test.py']</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args_for_reloading</span><span class="p">()</span>
            <span class="c"># 把环境变量(包括前面的fd等)</span>
            <span class="n">new_environ</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_environ</span><span class="p">[</span><span class="s">'WERKZEUG_RUN_MAIN'</span><span class="p">]</span> <span class="o">=</span> <span class="s">'true'</span>

            <span class="n">exit_code</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="n">new_environ</span><span class="p">,</span>
                                        <span class="n">close_fds</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">exit_code</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">exit_code</span>

    <span class="k">def</span> <span class="nf">trigger_reload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_reload</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">log_reload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">_log</span><span class="p">(</span><span class="s">'info'</span><span class="p">,</span> <span class="s">' * Detected change in </span><span class="si">%</span><span class="s">r, reloading'</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">trigger_reload</code>方法是供子类去调用的，子类监控到文件的变化时会去调用<code class="highlighter-rouge">trigger_reload</code>，并且使进程退出，退出码为3（3在这里表示这因为文件变化而退出）</p>

<p>可以看到，<code class="highlighter-rouge">ReloaderLoop</code>的<code class="highlighter-rouge">restart_with_reloader</code>方法会去启动一个<strong>子进程</strong>，并赋予所有的环境变量（包括fd），子进程会去带上<code class="highlighter-rouge">WERKZEUG_RUN_MAIN</code>参数重新去跑下前面的<code class="highlighter-rouge">run_simple</code>方法。并且会捕获子进程的退出码，如上面讲的，如果返回的是3的话，表示文件变化而倒是子进程退出，直接重启就好了，即继续循环，启动子进程；如果程序是因为其他原因退出的，则返回返回码。</p>

<h4 id="子进程">子进程</h4>

<p>接下来，我们看看子进程会做些什么。截止到上面的分析，我们知道，子进程相比较原先的父进程，目前唯一的泣别就是环境变量中<code class="highlighter-rouge">WERKZEUG_RUN_MAIN</code>为true，而这个字段会在两个地方会用到，一是最开始的<code class="highlighter-rouge">if use_reloader:</code>判断中，有这个字段的则不会去创建socket（毕竟父进程已经创建完成且把fd放在了环境变量中），二是<code class="highlighter-rouge">run_with_reloader</code>方法中。让我们再看下<code class="highlighter-rouge">run_with_reloader</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run_with_reloader</span><span class="p">(</span><span class="n">main_func</span><span class="p">,</span> <span class="n">extra_files</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                      <span class="n">reloader_type</span><span class="o">=</span><span class="s">'auto'</span><span class="p">):</span>
    <span class="s">"""Run the given function in an independent python interpreter."""</span>
    <span class="kn">import</span> <span class="nn">signal</span>
    <span class="n">reloader</span> <span class="o">=</span> <span class="n">reloader_loops</span><span class="p">[</span><span class="n">reloader_type</span><span class="p">](</span><span class="n">extra_files</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>
    <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">sys</span><span class="o">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'WERKZEUG_RUN_MAIN'</span><span class="p">)</span> <span class="o">==</span> <span class="s">'true'</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">main_func</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">())</span>
            <span class="n">t</span><span class="o">.</span><span class="n">setDaemon</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="n">reloader</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="nb">exit</span><span class="p">(</span><span class="n">reloader</span><span class="o">.</span><span class="n">restart_with_reloader</span><span class="p">())</span>
    <span class="k">except</span> <span class="nb">KeyboardInterrupt</span><span class="p">:</span>
        <span class="k">pass</span>

</code></pre></div></div>

<p>子进程到达了这个方法，会启动一个线程，运行<code class="highlighter-rouge">main_func</code>方法，也就是最开始的<code class="highlighter-rouge">inner</code>方法，用来启动一个server，该线程会被设置为<code class="highlighter-rouge">deamon</code>线程，即守护线程。守护线程会在其他线程退出后自动退出。</p>

<p>另外，reloader会运行<code class="highlighter-rouge">run()</code>方法，作用是监控文件的变化，并调用<code class="highlighter-rouge">trigger_reload</code>方法，在文件发生变化时退出，并返回3返回码。</p>

<p>还有一点，<code class="highlighter-rouge"> signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))</code>，这句看起来很简单，就是捕获<code class="highlighter-rouge">signal.SIGTERM</code>信号，也就是捕获kill或者是<code class="highlighter-rouge">ctrl + c</code>，并且退出。不过这里我还是有点疑问，为什么需要这个呢？加了信号之后唯一的区别，本来子进程退出会返回一个负数，加上之后会返回0。0代表着命令的成功执行，难道就是为了让程序更加’美丽’？</p>

<h4 id="再看reloaderloop">再看ReloaderLoop</h4>

<p>到了这里，整个流程算是理通了，就是我们一开始的原理。但还有一个问题我们之前一直选择跳过，就是<code class="highlighter-rouge">ReloaderLoop</code>的具体实现。我们前面说到，他有两个实现，分别为<code class="highlighter-rouge">StatReloaderLoop</code>以及<code class="highlighter-rouge">WatchdogReloaderLoop</code>。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reloader_loops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'stat'</span><span class="p">:</span> <span class="n">StatReloaderLoop</span><span class="p">,</span>
    <span class="s">'watchdog'</span><span class="p">:</span> <span class="n">WatchdogReloaderLoop</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">try</span><span class="p">:</span>
    <span class="nb">__import__</span><span class="p">(</span><span class="s">'watchdog.observers'</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">ImportError</span><span class="p">:</span>
    <span class="n">reloader_loops</span><span class="p">[</span><span class="s">'auto'</span><span class="p">]</span> <span class="o">=</span> <span class="n">reloader_loops</span><span class="p">[</span><span class="s">'stat'</span><span class="p">]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">reloader_loops</span><span class="p">[</span><span class="s">'auto'</span><span class="p">]</span> <span class="o">=</span> <span class="n">reloader_loops</span><span class="p">[</span><span class="s">'watchdog'</span><span class="p">]</span>
</code></pre></div></div>

<p>接下来，我们会细致得去看一下具体的实现。</p>

<h5 id="statreloaderloop">StatReloaderLoop</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">StatReloaderLoop</span><span class="p">(</span><span class="n">ReloaderLoop</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">'stat'</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mtimes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">(</span><span class="n">_iter_module_files</span><span class="p">(),</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">extra_files</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">mtime</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">st_mtime</span>
                <span class="k">except</span> <span class="nb">OSError</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">old_time</span> <span class="o">=</span> <span class="n">mtimes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">old_time</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">mtimes</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span> <span class="o">=</span> <span class="n">mtime</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">mtime</span> <span class="o">&gt;</span> <span class="n">old_time</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">trigger_reload</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">StatReloaderLoop</code>的实现很简单，就是挨个去看文件的上次修改时间来确认文件是否发生改变，需要注意的是，如果interval比较小而文件又比较多的情况下，这个方法会很耗资源（显而易见），剩下的没啥好说的…</p>

<h5 id="watchdogreloaderloop">WatchdogReloaderLoop</h5>

<p><code class="highlighter-rouge">WatchdogReloaderLoop</code>依赖了第三方的库<code class="highlighter-rouge">watchdog</code>，这是一个可以监控文件变化的库，跨平台，运维用的比较多。他允许自定义监控一系列文件的变化，并在变化时调用相应的handler。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">WatchdogReloaderLoop</span><span class="p">(</span><span class="n">ReloaderLoop</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">ReloaderLoop</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">watchdog.observers</span> <span class="kn">import</span> <span class="n">Observer</span>
        <span class="kn">from</span> <span class="nn">watchdog.events</span> <span class="kn">import</span> <span class="n">FileSystemEventHandler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observable_paths</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c"># 根据发生变化的文件名，确定是否需要重启(如果变动了一个不重要的小文件就没必要重启了)</span>
        <span class="k">def</span> <span class="nf">_check_modification</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">filename</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra_files</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trigger_reload</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">dirname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dirname</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observable_paths</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s">'.pyc'</span><span class="p">,</span> <span class="s">'.pyo'</span><span class="p">,</span> <span class="s">'.py'</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">trigger_reload</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="c"># 定义一个处理器类，分别处理不懂改变时要做的事(都是调用_check_modification方法)</span>
        <span class="k">class</span> <span class="nc">_CustomHandler</span><span class="p">(</span><span class="n">FileSystemEventHandler</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">on_created</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span> <span class="n">_check_modification</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">src_path</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">on_modified</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>  <span class="o">...</span>         
            <span class="k">def</span> <span class="nf">on_moved</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span> <span class="o">...</span>
            <span class="k">def</span> <span class="nf">on_deleted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span> <span class="o">...</span>
                        
        <span class="bp">self</span><span class="o">.</span><span class="n">observer_class</span> <span class="o">=</span> <span class="n">Observer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event_handler</span> <span class="o">=</span> <span class="n">_CustomHandler</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">should_reload</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">trigger_reload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="c"># 调用会发生在handler中，退出没什么卵用，所以覆写了这个方法，让run循环自动退出</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">should_reload</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_reload</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">watches</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">observer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observer_class</span><span class="p">()</span>
        <span class="n">observer</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_reload</span><span class="p">:</span>
                <span class="c"># 使用watchdog去检查文件是否发生变化，并使用handler去处理。</span>
        <span class="k">finally</span><span class="p">:</span>
           <span class="c"># observer是一个线程，让observer也正常退出</span>
            <span class="n">observer</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
            <span class="n">observer</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
		<span class="c"># 返回3，标识文件发生变化</span>
        <span class="n">sys</span><span class="o">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<p>这部分代码很长，我把不太重要的省略掉了。代码比较简单，注释都卸载里边了，简单的说就是使用watchdog的方式去调用处理文件变化的事件，并按正常流程退出。</p>

<h3 id="小结">小结</h3>

<p>werkzeug的代码真的很神，很多可以看的地方，比如父进程通过环境变量给子进程传递信息，父进程创建socket并获取其fd，子进程通过fd去创建socket，即便在重启的过程中也不至于<code class="highlighter-rouge">connection refused</code>，再比如使用退出码让子进程给父进程传递信息，再比如清晰的逻辑，各个环节的划分，reloader具体实现类的抽象等，都很值得学习。</p>

<p>我在看这代码之前想了很久，如果我来做reloader机制会如何去做，反正我做能实现功能就不错了…希望自己的代码有一天能这么好看吧。</p>


  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2018/05/function-type%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/" title="link to 对go中function type的一点思考">对go中function type的一点思考</a></h2>
       <p class="excerpt">function type 可以理解为一组拥有相同参数类型和结果类型的方法的集合。我看也有人管他叫接口型函数。  A function type denotes the set of all functions with the same parameter and result types. The value of an uninitialized variable of function type is nil.  Two function types are identical i...&hellip;</p>
       <div class="post-list__meta"><time datetime="2018-05-30 21:00:00 +0800" class="post-list__meta--date date">2018-05-30</time> &#8226; <span class="post-list__meta--tags tags">go</span><a class="btn-border-small" href=/2018/05/function-type%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2018/04/TIME_WAIT%E7%8A%B6%E6%80%81%E5%AD%98%E5%9C%A8%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/" title="link to TIME_WAIT状态存在的意义">TIME_WAIT状态存在的意义</a></h2>
       <p class="excerpt">什么时候会TIME_WAITTCP在关闭的时候有个四次挥手的过程，主动关闭方在四次挥手的最后一个ACK发送之后会变成TIME_WAIT状态。主动关闭方跟握手不同，挥手可以由客户端发起，也可以是服务端发起。发起关闭的一端我们称之为主动关闭方，另一端称之为被动关闭方。四次挥手  主动关闭方会发送一个FIN给被动关闭方，表示数据已经发送完毕。  被动关闭方接收到FIN，响应一个ACK。它的接收作为一个文件结束符（end-of-file）传递给接收端应用进程（放在所有已排队等候该应用进程接收的任何...&hellip;</p>
       <div class="post-list__meta"><time datetime="2018-04-20 21:00:00 +0800" class="post-list__meta--date date">2018-04-20</time> &#8226; <span class="post-list__meta--tags tags">tcp</span><a class="btn-border-small" href=/2018/04/TIME_WAIT%E7%8A%B6%E6%80%81%E5%AD%98%E5%9C%A8%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
  
    <div id="disqus_thread"></div>
    <script>
    
    var disqus_config = function () {
        this.page.url = "http://gaoconghui.github.io/2018/04/%E5%93%81%E8%AF%BBwerkzeug-reloader/";
        this.page.identifier = "/2018/04/%E5%93%81%E8%AF%BBwerkzeug-reloader/";
    };

    var disqus_shortname = 'vno-jekyll';
    
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>要查看<a href="http://disqus.com/?ref_noscript"> Disqus </a>评论，请启用 JavaScript</noscript>
    
  
  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">本站由 <a href="http://onev.cat">@onevcat</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/onevcat/OneV-s-Den">本站源码</a> - &copy; 2018</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/main.js"></script>



    
  </body>

</html>
