<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>groupcache源码中几个有趣的点</title>
  <meta name="description" content="简介">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="groupcache源码中几个有趣的点">
  <meta name="twitter:description" content="简介">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="groupcache源码中几个有趣的点">
  <meta property="og:description" content="简介">
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://gaoconghui.github.io/2018/06/groupcache/">
  <link rel="alternate" type="application/rss+xml" title="Gao Conghui" href="http://gaoconghui.github.io/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 Gao Conghui 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="Gao Conghui logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for Gao Conghui" class="blog-button">Gao Conghui</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">好好学习，天天向上</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">一点资讯，视频爬虫，视频处理。</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="Visit blog" class="blog-button">Blog</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/https://github.com/gaoconghui" title="@https://github.com/gaoconghui 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:381147882@qq.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-blue"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-06-06 21:00:00 +0800" itemprop="datePublished" class="post-meta__date date">2018-06-06</time> &#8226; <span class="post-meta__tags tags">go</span>
    </div>
    <h1 class="post-title">groupcache源码中几个有趣的点</h1>
  </header>

  <section class="post">
    <h3 id="简介">简介</h3>

<blockquote>
  <p>groupcache is a caching and cache-filling library, intended as a replacement for memcached in many cases.</p>
</blockquote>

<p>groupcache是一个可分布式缓存组件，用于在某些方面替代memcache，不过和一般的缓存有些区别，它只能做get操作（没错，只能get），但是不能做更新和删除操作。另外，groupcache可以很方便的集成到应用程序中，用http接口的形式与其他程序交互。</p>

<h4 id="几个概念">几个概念</h4>

<ul>
  <li>peer 代表一个缓存服务器</li>
  <li>group 缓存以group的概念做组的划分，可以有多个group，每个group有不同的获取数据的方法</li>
</ul>

<h4 id="几个文件">几个文件</h4>

<ul>
  <li>
    <p>sinks.go 用来装cache的值，可以支持多种类型。</p>
  </li>
  <li>
    <p>consistenthash/consistenthash.go 一个一致性hash的实现</p>
  </li>
  <li>http.go 提供peer之间的交互。依赖<code class="highlighter-rouge">consistenthash</code>提供的一致性hash的方案，查找key对应的缓存服务器并发出请求，以及提供接口给其他peer访问</li>
  <li>peers.go 提供了几个和peer相关的方法，如根据groupname获取peer</li>
  <li>groupcache.go 核心文件，提供获取缓存的方法（先查找本地再查找远端）</li>
  <li>singleflight/singleflight.go 提供一个竞争执行方法的方法</li>
  <li>lru/lru.go 顾名思义 ，提供lru的实现</li>
</ul>

<h3 id="基本使用方式">基本使用方式</h3>

<p><strong>创建group</strong></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 需要提供一个获取的getter方法</span><span class="x">
</span><span class="k">var</span><span class="x"> </span><span class="n">Group</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">groupcache</span><span class="o">.</span><span class="n">NewGroup</span><span class="p">(</span><span class="s">"colorCache"</span><span class="p">,</span><span class="x"> </span><span class="m">64</span><span class="o">&lt;&lt;</span><span class="m">20</span><span class="p">,</span><span class="x"> </span><span class="n">groupcache</span><span class="o">.</span><span class="n">GetterFunc</span><span class="p">(</span><span class="x">
	</span><span class="k">func</span><span class="p">(</span><span class="n">ctx</span><span class="x"> </span><span class="n">groupcache</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span><span class="x"> </span><span class="n">key</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">dest</span><span class="x"> </span><span class="n">groupcache</span><span class="o">.</span><span class="n">Sink</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"looking up"</span><span class="p">,</span><span class="x"> </span><span class="n">key</span><span class="p">)</span><span class="x">
      	</span><span class="c">// 这里从数据库中获取一个值 </span><span class="x">
		</span><span class="n">v</span><span class="p">,</span><span class="x"> </span><span class="n">ok</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">Store</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="x">
		</span><span class="k">if</span><span class="x"> </span><span class="o">!</span><span class="n">ok</span><span class="x"> </span><span class="p">{</span><span class="x">
			</span><span class="k">return</span><span class="x"> </span><span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"color not found"</span><span class="p">)</span><span class="x">
		</span><span class="p">}</span><span class="x">
		</span><span class="n">dest</span><span class="o">.</span><span class="n">SetBytes</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="x">
		</span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="x">
	</span><span class="p">},</span><span class="x">
</span><span class="p">))</span><span class="x">
</span></code></pre></div></div>

<p><strong>设置peers并启动服务</strong></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// peer是本缓存服务服务的地址 如http://localhost:8080</span><span class="x">
</span><span class="n">pool</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">groupcache</span><span class="o">.</span><span class="n">NewHTTPPool</span><span class="p">(</span><span class="n">peer</span><span class="p">)</span><span class="x">
</span><span class="c">// ps是一组缓存服务器的地址</span><span class="x">
</span><span class="n">pool</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">ps</span><span class="o">...</span><span class="p">)</span><span class="x">
</span><span class="n">http</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="x"> </span><span class="no">nil</span><span class="p">)</span><span class="x">
</span></code></pre></div></div>

<p><strong>获取缓存</strong></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="n">b</span><span class="x"> </span><span class="p">[]</span><span class="kt">byte</span><span class="x">
</span><span class="c">// 获取缓存结果，存在b中。AllocatingByteSliceSink是一个对获取数据的包装</span><span class="x">
</span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">Group</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span><span class="x"> </span><span class="n">color</span><span class="p">,</span><span class="x"> </span><span class="n">groupcache</span><span class="o">.</span><span class="n">AllocatingByteSliceSink</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">))</span><span class="x">
</span></code></pre></div></div>

<h3 id="几个有趣的点">几个有趣的点</h3>

<h4 id="peer的查询">peer的查询</h4>

<p>给定一个key，groupcache会在本地找不到缓存的情况下，查询该key应该存在的peer。为了在新增或删除peer的时候尽量少的缓存失效，groupcache使用一致性hash的方案，并提供了一个consistenthash的实现，就在consistenthash/consistenthash.go中。</p>

<p>不赘述什么是一致性hash了，直接以注释分析的方式给出代码</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">Hash</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">data</span><span class="x"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="x"> </span><span class="kt">uint32</span><span class="x">

</span><span class="c">// hash 一个hash算法，默认为crc32.ChecksumIEEE</span><span class="x">
</span><span class="c">// replicas 每个peer节点会产生几个虚拟节点</span><span class="x">
</span><span class="c">// keys 储存所有虚拟节点的hash值</span><span class="x">
</span><span class="c">// hashMap 根据hash值找到相应的peer</span><span class="x">
</span><span class="k">type</span><span class="x"> </span><span class="n">Map</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">hash</span><span class="x">     </span><span class="n">Hash</span><span class="x">
	</span><span class="n">replicas</span><span class="x"> </span><span class="kt">int</span><span class="x">
	</span><span class="n">keys</span><span class="x">     </span><span class="p">[]</span><span class="kt">int</span><span class="x"> </span><span class="c">// Sorted</span><span class="x">
	</span><span class="n">hashMap</span><span class="x">  </span><span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">New</span><span class="p">(</span><span class="n">replicas</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">fn</span><span class="x"> </span><span class="n">Hash</span><span class="p">)</span><span class="x"> </span><span class="o">*</span><span class="n">Map</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">m</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">&amp;</span><span class="n">Map</span><span class="p">{</span><span class="x">
		</span><span class="n">replicas</span><span class="o">:</span><span class="x"> </span><span class="n">replicas</span><span class="p">,</span><span class="x">
		</span><span class="n">hash</span><span class="o">:</span><span class="x">     </span><span class="n">fn</span><span class="p">,</span><span class="x">
		</span><span class="n">hashMap</span><span class="o">:</span><span class="x">  </span><span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">m</span><span class="o">.</span><span class="n">hash</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">m</span><span class="o">.</span><span class="n">hash</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">crc32</span><span class="o">.</span><span class="n">ChecksumIEEE</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="n">m</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="c">// Returns true if there are no items available.</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">m</span><span class="x"> </span><span class="o">*</span><span class="n">Map</span><span class="p">)</span><span class="x"> </span><span class="n">IsEmpty</span><span class="p">()</span><span class="x"> </span><span class="kt">bool</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="m">0</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="c">// Adds some keys to the hash.</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">m</span><span class="x"> </span><span class="o">*</span><span class="n">Map</span><span class="p">)</span><span class="x"> </span><span class="n">Add</span><span class="p">(</span><span class="n">keys</span><span class="x"> </span><span class="o">...</span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">key</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">keys</span><span class="x"> </span><span class="p">{</span><span class="x">
      </span><span class="c">// 一个key就是一个peer节点</span><span class="x">
      </span><span class="c">// 对于每个key，都会生成replicas个虚拟节点，并把虚拟节点和key的对应关系存起来</span><span class="x">
		</span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="n">m</span><span class="o">.</span><span class="n">replicas</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
			</span><span class="n">hash</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="kt">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">hash</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">strconv</span><span class="o">.</span><span class="n">Itoa</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="x"> </span><span class="o">+</span><span class="x"> </span><span class="n">key</span><span class="p">)))</span><span class="x">
			</span><span class="n">m</span><span class="o">.</span><span class="n">keys</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">keys</span><span class="p">,</span><span class="x"> </span><span class="n">hash</span><span class="p">)</span><span class="x">
			</span><span class="n">m</span><span class="o">.</span><span class="n">hashMap</span><span class="p">[</span><span class="n">hash</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">key</span><span class="x">
		</span><span class="p">}</span><span class="x">
	</span><span class="p">}</span><span class="x">
  </span><span class="c">// 排序 方便后边查找</span><span class="x">
	</span><span class="n">sort</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="c">// 这边的key为一个cache中的key，即要查询的key</span><span class="x">
</span><span class="c">// 计算这个key的hash值，找到与之最为接近的虚拟节点，再通过虚拟节点找到具体的peer</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">m</span><span class="x"> </span><span class="o">*</span><span class="n">Map</span><span class="p">)</span><span class="x"> </span><span class="n">Get</span><span class="p">(</span><span class="n">key</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="kt">string</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">m</span><span class="o">.</span><span class="n">IsEmpty</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="k">return</span><span class="x"> </span><span class="s">""</span><span class="x">
	</span><span class="p">}</span><span class="x">

  </span><span class="c">// 计算key对应的hash值</span><span class="x">
	</span><span class="n">hash</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="kt">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">hash</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">key</span><span class="p">)))</span><span class="x">

	</span><span class="c">// 使用二分法查找key对应的hash值最近的虚拟节点</span><span class="x">
	</span><span class="n">idx</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">sort</span><span class="o">.</span><span class="n">Search</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">keys</span><span class="p">),</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">i</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">bool</span><span class="x"> </span><span class="p">{</span><span class="x"> </span><span class="k">return</span><span class="x"> </span><span class="n">m</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x"> </span><span class="o">&gt;=</span><span class="x"> </span><span class="n">hash</span><span class="x"> </span><span class="p">})</span><span class="x">

	</span><span class="c">// 一致性hash的虚拟节点应该构成一个环</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">idx</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">idx</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="m">0</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="k">return</span><span class="x"> </span><span class="n">m</span><span class="o">.</span><span class="n">hashMap</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>很经典的实现。</p>

<h4 id="cache的查找过程">cache的查找过程</h4>

<p>简单的说，就是<code class="highlighter-rouge">Group.Get(nil, color, groupcache.AllocatingByteSliceSink(&amp;b))</code>发生了什么。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">g</span><span class="x"> </span><span class="o">*</span><span class="n">Group</span><span class="p">)</span><span class="x"> </span><span class="n">Get</span><span class="p">(</span><span class="n">ctx</span><span class="x"> </span><span class="n">Context</span><span class="p">,</span><span class="x"> </span><span class="n">key</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">dest</span><span class="x"> </span><span class="n">Sink</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="c">// ... (省略一些不重要的代码)</span><span class="x">
  </span><span class="c">// 查询本地的缓存，很简单的方法</span><span class="x">
	</span><span class="n">value</span><span class="p">,</span><span class="x"> </span><span class="n">cacheHit</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">g</span><span class="o">.</span><span class="n">lookupCache</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="x">

  </span><span class="c">// 如果命中，统计完直接返回</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">cacheHit</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">g</span><span class="o">.</span><span class="n">Stats</span><span class="o">.</span><span class="n">CacheHits</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="x">
		</span><span class="k">return</span><span class="x"> </span><span class="n">setSinkView</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span><span class="x"> </span><span class="n">value</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="c">// 这边是关键 </span><span class="x">
	</span><span class="n">destPopulated</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="no">false</span><span class="x">
	</span><span class="n">value</span><span class="p">,</span><span class="x"> </span><span class="n">destPopulated</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">g</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span><span class="x"> </span><span class="n">key</span><span class="p">,</span><span class="x"> </span><span class="n">dest</span><span class="p">)</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="k">return</span><span class="x"> </span><span class="n">err</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">destPopulated</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="n">setSinkView</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span><span class="x"> </span><span class="n">value</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span></code></pre></div></div>

<p>如代码的注释，关键在于在本地没找到缓存的情况下，需要找到合适的peer（可能是自己）去计算出值。这里需要考虑一个问题，就是如果本地有两个协程同时查询一个key怎么办，groupcache会阻塞其中一个，让另一个先跑出结果，避免调用两次获取方法。<code class="highlighter-rouge">destPopulated</code>标记该值是不是由该peer新计算出来的（本地方法获取后会直接赋值dest）。</p>

<p>让我们看一下这边的load方法</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">g</span><span class="x"> </span><span class="o">*</span><span class="n">Group</span><span class="p">)</span><span class="x"> </span><span class="n">load</span><span class="p">(</span><span class="n">ctx</span><span class="x"> </span><span class="n">Context</span><span class="p">,</span><span class="x"> </span><span class="n">key</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">dest</span><span class="x"> </span><span class="n">Sink</span><span class="p">)</span><span class="x"> </span><span class="p">(</span><span class="n">value</span><span class="x"> </span><span class="n">ByteView</span><span class="p">,</span><span class="x"> </span><span class="n">destPopulated</span><span class="x"> </span><span class="kt">bool</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">g</span><span class="o">.</span><span class="n">Stats</span><span class="o">.</span><span class="n">Loads</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="x">
  </span><span class="c">// loadGroup.Do是个竞争的方法，相同的key同时只会有一个访问</span><span class="x">
	</span><span class="n">viewi</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">g</span><span class="o">.</span><span class="n">loadGroup</span><span class="o">.</span><span class="n">Do</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">(</span><span class="k">interface</span><span class="p">{},</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
      </span><span class="c">// 可能存在两个并发访问了这个方法，后执行的协程可能可以直接从缓存中读入</span><span class="x">
		</span><span class="k">if</span><span class="x"> </span><span class="n">value</span><span class="p">,</span><span class="x"> </span><span class="n">cacheHit</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">g</span><span class="o">.</span><span class="n">lookupCache</span><span class="p">(</span><span class="n">key</span><span class="p">);</span><span class="x"> </span><span class="n">cacheHit</span><span class="x"> </span><span class="p">{</span><span class="x">
			</span><span class="n">g</span><span class="o">.</span><span class="n">Stats</span><span class="o">.</span><span class="n">CacheHits</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="x">
			</span><span class="k">return</span><span class="x"> </span><span class="n">value</span><span class="p">,</span><span class="x"> </span><span class="no">nil</span><span class="x">
		</span><span class="p">}</span><span class="x">
		</span><span class="n">g</span><span class="o">.</span><span class="n">Stats</span><span class="o">.</span><span class="n">LoadsDeduped</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="x">
		</span><span class="k">var</span><span class="x"> </span><span class="n">value</span><span class="x"> </span><span class="n">ByteView</span><span class="x">
		</span><span class="k">var</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="x">
      </span><span class="c">// 根据上边的一致性hash，找到peer</span><span class="x">
		</span><span class="k">if</span><span class="x"> </span><span class="n">peer</span><span class="p">,</span><span class="x"> </span><span class="n">ok</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">g</span><span class="o">.</span><span class="n">peers</span><span class="o">.</span><span class="n">PickPeer</span><span class="p">(</span><span class="n">key</span><span class="p">);</span><span class="x"> </span><span class="n">ok</span><span class="x"> </span><span class="p">{</span><span class="x">
          </span><span class="c">// 从peer中获取值</span><span class="x">
			</span><span class="n">value</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">g</span><span class="o">.</span><span class="n">getFromPeer</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span><span class="x"> </span><span class="n">peer</span><span class="p">,</span><span class="x"> </span><span class="n">key</span><span class="p">)</span><span class="x">
			</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
				</span><span class="n">g</span><span class="o">.</span><span class="n">Stats</span><span class="o">.</span><span class="n">PeerLoads</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="x">
				</span><span class="k">return</span><span class="x"> </span><span class="n">value</span><span class="p">,</span><span class="x"> </span><span class="no">nil</span><span class="x">
			</span><span class="p">}</span><span class="x">
			</span><span class="n">g</span><span class="o">.</span><span class="n">Stats</span><span class="o">.</span><span class="n">PeerErrors</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="x">
		</span><span class="p">}</span><span class="x">
      </span><span class="c">// 不需要访问远端peer，可以直接自己获取</span><span class="x">
		</span><span class="n">value</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">g</span><span class="o">.</span><span class="n">getLocally</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span><span class="x"> </span><span class="n">key</span><span class="p">,</span><span class="x"> </span><span class="n">dest</span><span class="p">)</span><span class="x">
		</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
			</span><span class="n">g</span><span class="o">.</span><span class="n">Stats</span><span class="o">.</span><span class="n">LocalLoadErrs</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="x">
			</span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x">
		</span><span class="p">}</span><span class="x">
		</span><span class="n">g</span><span class="o">.</span><span class="n">Stats</span><span class="o">.</span><span class="n">LocalLoads</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="x">
		</span><span class="n">destPopulated</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="no">true</span><span class="x"> </span><span class="c">// only one caller of load gets this return value</span><span class="x">
		</span><span class="c">// 缓存起来</span><span class="x">
      	 </span><span class="n">g</span><span class="o">.</span><span class="n">populateCache</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="x"> </span><span class="n">value</span><span class="p">,</span><span class="x"> </span><span class="o">&amp;</span><span class="n">g</span><span class="o">.</span><span class="n">mainCache</span><span class="p">)</span><span class="x">
		</span><span class="k">return</span><span class="x"> </span><span class="n">value</span><span class="p">,</span><span class="x"> </span><span class="no">nil</span><span class="x">
	</span><span class="p">})</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">value</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">viewi</span><span class="o">.</span><span class="p">(</span><span class="n">ByteView</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="k">return</span><span class="x">
</span><span class="p">}</span><span class="x">

</span></code></pre></div></div>

<p>还需要解释最后一个问题，如何控制并发的访问。这边使用的是<code class="highlighter-rouge">g.loadGroup.Do</code>方法，<code class="highlighter-rouge">loadGroup</code>是一个<code class="highlighter-rouge">singleflight.Group</code>。让我们看一下这个Do方法做了啥。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">singleflight</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="s">"sync"</span><span class="x">

</span><span class="c">// 包装一个key获取值锁需要的一些参数</span><span class="x">
</span><span class="k">type</span><span class="x"> </span><span class="n">call</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">wg</span><span class="x">  </span><span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="x">
	</span><span class="n">val</span><span class="x"> </span><span class="k">interface</span><span class="p">{}</span><span class="x">
	</span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">Group</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">mu</span><span class="x"> </span><span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span><span class="x">       </span><span class="c">// protects m</span><span class="x">
	</span><span class="n">m</span><span class="x">  </span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">call</span><span class="x"> </span><span class="c">// lazily initialized</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">g</span><span class="x"> </span><span class="o">*</span><span class="n">Group</span><span class="p">)</span><span class="x"> </span><span class="n">Do</span><span class="p">(</span><span class="n">key</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">fn</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">(</span><span class="k">interface</span><span class="p">{},</span><span class="x"> </span><span class="kt">error</span><span class="p">))</span><span class="x"> </span><span class="p">(</span><span class="k">interface</span><span class="p">{},</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">g</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span><span class="x">
  </span><span class="c">// 懒加载</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">g</span><span class="o">.</span><span class="n">m</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">g</span><span class="o">.</span><span class="n">m</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">call</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">
  </span><span class="c">// 已经有协程在处理了，阻塞(c.wg.Wait())等待完成</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">c</span><span class="p">,</span><span class="x"> </span><span class="n">ok</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">g</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">key</span><span class="p">];</span><span class="x"> </span><span class="n">ok</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">g</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span><span class="x">
		</span><span class="n">c</span><span class="o">.</span><span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span><span class="x">
		</span><span class="k">return</span><span class="x"> </span><span class="n">c</span><span class="o">.</span><span class="n">val</span><span class="p">,</span><span class="x"> </span><span class="n">c</span><span class="o">.</span><span class="n">err</span><span class="x">
	</span><span class="p">}</span><span class="x">
  </span><span class="c">// 目前没有协程在处理，新建一个处理的任务</span><span class="x">
	</span><span class="n">c</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">new</span><span class="p">(</span><span class="n">call</span><span class="p">)</span><span class="x">
	</span><span class="n">c</span><span class="o">.</span><span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="x">
	</span><span class="n">g</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">c</span><span class="x">
	</span><span class="n">g</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span><span class="x">

	</span><span class="n">c</span><span class="o">.</span><span class="n">val</span><span class="p">,</span><span class="x"> </span><span class="n">c</span><span class="o">.</span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">fn</span><span class="p">()</span><span class="x">
	</span><span class="n">c</span><span class="o">.</span><span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span><span class="x">

	</span><span class="n">g</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span><span class="x">
	</span><span class="nb">delete</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">m</span><span class="p">,</span><span class="x"> </span><span class="n">key</span><span class="p">)</span><span class="x">
	</span><span class="n">g</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span><span class="x">

	</span><span class="k">return</span><span class="x"> </span><span class="n">c</span><span class="o">.</span><span class="n">val</span><span class="p">,</span><span class="x"> </span><span class="n">c</span><span class="o">.</span><span class="n">err</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>这个方法还是比较简单的，主要就是使用<code class="highlighter-rouge">sync.WaitGroup</code>来保证只有一个协程在真的调用<code class="highlighter-rouge">fn</code>方法获取值，剩下的都在等待获取完成。</p>

<h3 id="小结">小结</h3>

<p>看groupcache源码纯粹只是为了学习优秀的go的代码，并没有在实际中使用过… 不过这代码还是很有意思的。</p>

  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2018/06/golang-hijack%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/" title="link to golang hijack打开方式">golang hijack打开方式</a></h2>
       <p class="excerpt">简介Hijacktype Hijacker interface {	// Hijack lets the caller take over the connection.	// After a call to Hijack the HTTP server library	// will not do anything else with the connection.	//	// It becomes the caller's responsibility to manage	// and...&hellip;</p>
       <div class="post-list__meta"><time datetime="2018-06-13 21:00:00 +0800" class="post-list__meta--date date">2018-06-13</time> &#8226; <span class="post-list__meta--tags tags">go</span><a class="btn-border-small" href=/2018/06/golang-hijack%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2018/05/function-type%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/" title="link to 对go中function type的一点思考">对go中function type的一点思考</a></h2>
       <p class="excerpt">function type 可以理解为一组拥有相同参数类型和结果类型的方法的集合。我看也有人管他叫接口型函数。  A function type denotes the set of all functions with the same parameter and result types. The value of an uninitialized variable of function type is nil.  Two function types are identical i...&hellip;</p>
       <div class="post-list__meta"><time datetime="2018-05-30 21:00:00 +0800" class="post-list__meta--date date">2018-05-30</time> &#8226; <span class="post-list__meta--tags tags">go</span><a class="btn-border-small" href=/2018/05/function-type%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
  
    <div id="disqus_thread"></div>
    <script>
    
    var disqus_config = function () {
        this.page.url = "http://gaoconghui.github.io/2018/06/groupcache/";
        this.page.identifier = "/2018/06/groupcache/";
    };

    var disqus_shortname = 'vno-jekyll';
    
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>要查看<a href="http://disqus.com/?ref_noscript"> Disqus </a>评论，请启用 JavaScript</noscript>
    
  
  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">本站由 <a href="http://onev.cat">@onevcat</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/onevcat/OneV-s-Den">本站源码</a> - &copy; 2018</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/main.js"></script>



    
  </body>

</html>
